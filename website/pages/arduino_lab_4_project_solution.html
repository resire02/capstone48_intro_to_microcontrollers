<!DOCTYPE html>
<html lang="en">

<head>
    <title>Arduino: Final Project Solution</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Manuals about the basics of microcontrollers"/>
    <link rel="stylesheet" href="../globals.css">
</head>

<body>
    <header class="page-header">
            <div class="page-title">
                <img src="../images/128px-Microchip_Technology_logo.svg" />
                <a href="index.html" style="text-decoration: none;color:black;">
                    <h1>Introduction to Microcontrollers</h1>
                </a>
            </div>
            <div class="page-subheader">
                <ul>
                    <li>
                        <strong>Arduino</strong>
                    </li>
                    <li>
                        <a href="../pages/arduino_lab_0.html">Lab 0</a>
                    </li>
                    <li>
                        <a href="../pages/arduino_lab_1.html">Lab 1</a>
                    </li>
                    <li>
                        <a href="../pages/arduino_lab_2.html">Lab 2</a>
                    </li>
                    <li>
                        <a href="../pages/arduino_lab_3.html">Lab 3</a>
                    </li>
                    <li>
                        <a href="../pages/arduino_lab_4_project_requirements.html">Lab 4</a>
                    </li>
                    <li>
                        <a href="../pages/arduino_lab_4_project_solution.html">Lab 4 Solution</a>
                    </li>
                    <li>
                        <strong>MPLAB X IDE</strong>
                    </li>
                    <li>
                        <a href="../pages/mplabx_lab_0.html">Lab 0</a>
                    </li>
                    <li>
                        <a href="../pages/mplabx_lab_1.html">Lab 1</a>
                    </li>
                    <li>
                        <a href="../pages/mplabx_lab_2.html">Lab 2</a>
                    </li>
                    <li>
                        <a href="../pages/mplabx_lab_3.html">Lab 3</a>
                    </li>
                    <li>
                        <a href="../pages/mplabx_lab_4.html">Lab 4</a>
                    </li>
                    <li>
                        <a href="../pages/mplabx_lab_5.html">Lab 5</a>
                    </li>
                    <li>
                        <a href="../pages/mplabx_lab_6.html">Lab 6</a>
                    </li>
                </ul>
            </div>
        </header>
    <main>
        <h1 class="lab-header">Lab 4: Interactive Home Automation and Monitoring System</h1>
        <section>
            <h2 class="section-header-title">Requirements</h2>
            <p>
                This lab requires the following materials:
            <ul>
                <li>A computer with Arduino IDE installed (with DXCore libraries)</li>
                <li>AVR64DD32 Curiosity Nano</li>
                <li>EV58G97A Curiosity Explorer Board</li>
                <li>Standard USB to Micro USB cable</li>
            </ul>
            </p>
        </section>
        <section>
            <h2 class="section-header-title">Learning Objectives</h2>
            <p>
                In this lab, we will bring together everything we've covered so far into one comprehensive project: a
                home monitoring and automation system. Unlike previous labs, this one will focus on integrating various
                components into a single project. Below, you'll find the requirements that your project and code need to
                meet. At the end of the lab, we will review a solution that satisfies all the requirements.
            </p>
        </section>
        <section>
            <h2 class="section-header-title">System Features</h2>
            <p>
            <ul>
                <li>Smart Lock with Password</li>
                <ul>
                    <li>Accept a user-entered password, compare it against a stored password, and grant access to the
                        smart home entry if the passwords match, or deny access if they do not match.</li>
                    <li>Display password input on the OLED screen.</li>
                </ul>
                <li>Door Bell</li>
                <ul>
                    <li>When the joystick is pressed in, the system plays a sound similar to a doorbell.</li>
                </ul>
                <li>Temperature Sensor</li>
                <ul>
                    <li>Read temperature data from the MCP9808 temperature sensor on the board.</li>
                    <li>Based on the temperature value read from the sensor, adjust the color of the RGB LED. The LED
                        should transition from blue (cold) to red (hot), depending on the temperature.</li>
                </ul>
                <li>Room Selector</li>
                <ul>
                    <li>Turning the potentiometer selects one of the 8 rooms (LEDs) on the digitally addressable LEDs,
                        with the selected room highlighted in the current temperature color (default is blue).</li>
                </ul>
                <li>Smart Lighting</li>
                <ul>
                    <li>Each LED on the digitally addressable LEDs represents a room's temperature setting, defaulting
                        to blue (cool) and changing to green (normal) or red (warm) when SW1, SW2, or SW3 is pressed,
                        respectively, with each room's setting preserved while the board remains powered.</li>
                </ul>
                <li>Joystick</li>
                <ul>
                    <li>The joystick should retrieve input from all 4 directions (up, down, left, right).</li>
                </ul>
                <li>Distance Sensor</li>
                <ul>
                    <li>Read data from the distance sensor VCNL4200.</li>
                    <li>Based on the data from the distance sensor, make the Amber LEDS light up so that the closer an
                        object is to the distance sensor the more LEDs light up.</li>
                </ul>
            </ul>
            </p>
        </section>
        <section>
            <h2 class="section-header-title">Code Walkthrough for Password Entry</h2>
            <p>

                Objective: Implement password entry for a smart lock system

                The password is either set by a new user or verified by an existing user. The system uses an OLED
                display to show the password entry process and EEPROM to store and retrieve the password.

                First, include the necessary external libraries to support OLED display and EEPROM password storage.
                Instantiate an OLED display object. Set the password slot to 11, as we already utilized the first 10
                slots in our previous EEPROM sketch.

                The full source code for this sketch is located at [05_lab-project/SmartLock/SmartLock.ino]()

            <pre><code class="'language-c">
#include &lt;SPI.h&gt;
#include &lt;Wire.h&gt;
#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_SSD1306.h&gt;
#include &lt;EEPROM.h&gt;

#define SCREEN_WIDTH 128      // OLED display width, in pixels
#define SCREEN_HEIGHT 64      // OLED display height, in pixels
#define OLED_RESET -1         // Reset pin, set to -1
#define SCREEN_ADDRESS 0x3D   // 7-bit I2C Address
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
uint8_t pos = 5; // Initial position for text input on the OLED

#define PASSWORD_SLOT 11
            </code></pre>

            Initialize the display and draw 6 underscore characters on the display as placeholders for the password.

            <pre><code class="'language-c">
void setup() {
    delay(1000); // Wait for the display to ready
    if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
        for(;;); // Display not connected or malfunctioning, loop forever
    }
    display.clearDisplay();
    for (int i = 0; i &lt; 6; i++) {
        display.drawChar(pos, 40, '_', 1, 0, 2);
        display.drawChar(pos, 40, ' ', 1, 0, 1);
        pos += 20;
    }
    display.display(); // Display draw operations on screen 
}
            </code></pre>

            Swap the default UART to the appropriate one, and call the checkForStoredPassword() function. The successful
            execution of checkForStoredPassword() allows the program to proceed to the next step in the setup()
            function, where we can continue to the loop function.

            <pre><code class="'language-c">
Serial.swap(3);
Serial.begin(115200);
delay(100);
checkForStoredPassword();
            </code></pre>

            <img src="../images/arduino_lab4/OLED_underscore.jpg"
                style="max-height: 800px; width: 400px;">

            <p>
                The checkForStoredPassword() function checks if there is a stored password by reading the EEPROM at the
                PASSWORD_SLOT. If a password exists, it prompts the user to enter the password. If no password is found,
                it
                prompts the user to create a new one.
            </p>

            <pre><code class="'language-c">
void checkForStoredPassword() {
    Serial.println("Welcome!");
    if (EEPROM.read(PASSWORD_SLOT) != 0xFF) {
        Serial.println("Password found. Please enter the stored password.");
        handlePasswordInput(false);
    }
    else {
        Serial.println("No password found. Create a new one.");
        handlePasswordInput(true);
    }
}
            </code></pre>

            <img src="../images/arduino_lab4/OLED_uart_password_login.png"
                style="max-height: 800px; width: 400px;">

            <img src="../images/arduino_lab4/OLED_uart_no_password.png"
                style="max-height: 800px; width: 400px;">
            <p>
                The function handlePasswordInput() prompts the user to either create a new password or enter an existing
                one. It reads the input from the serial monitor, checking that it is exactly 6 characters long, and
                displaying it to the OLED. If creating a new password, it calls savePassword(input) to store the
                password in
                EEPROM. If verifying an existing password, it calls verifyPassword(input) to check if the entered
                password
                matches the stored password. If the password is incorrect, it asks the user to try again.
            </p>

            <pre><code class="'language-c">
void handlePasswordInput(bool newUser) {
    Serial.println(newUser ? "Create a new password:" :
    "Enter your password:");
    String input;
    bool passed = false;
    while (!passed) {
        pos = 5;
        if (Serial.available() > 0) {
            input = Serial.readStringUntil('\n'); // Read the input until newline
            if (input.length() == 6) {
                for (int i = 0; i &lt; 6; i++) {
                    char displayChar = (i &lt; input.length()) ? input[i] : ' ';
                    display.drawChar(pos, 20, displayChar, 1, 0, 2);
                    display.drawChar(pos, 40, '_', 1, 0, 2);
                    pos += 20;
                }
                if (newUser) {
                    passed = true;
                    savePassword(input);
                }
                else {
                    if (verifyPassword(input)) {
                        passed = true;
                    }
                    else {
                        Serial.println("Incorrect Password. Try Again.");
                    }
                }
            }
            else {
                Serial.println("Password must be exactly 6 characters. Try again.");
            }
        }
        display.display();
    }
}
            </code></pre>

            <img src="../images/arduino_lab4/OLED_pass.jpg"
                style="max-height: 800px; width: 400px;">

            <p>
                The function savePassword() saves the 6-digit password entered by the user into the EEPROM, starting
                from
                address 11. Each character in the password is converted to an integer and stored in consecutive EEPROM
                locations.
            </p>

            <pre><code class="'language-c">
void savePassword(String input) {
    for (int i = 0; i &lt; 6; i++) {
        int cell = i + 11;
        int digit = input[i] - '0';
        EEPROM.update(cell, digit);
    }
    int read_value;
    for (EEPtr ptr = 11; ptr.index &lt; 17; ptr++) {
        read_value = *ptr;
    }
}
            </code></pre>

            This function verifyPassword(String input) checks if the entered password matches the stored password in
            EEPROM. It compares each digit of the input password with the corresponding value in EEPROM. If any digit
            does not match, it returns false, indicating an incorrect password.

            <pre><code class="'language-c">
bool verifyPassword(String input) {
    int read_value;
    int i = 0;
    for (EEPtr ptr = 11; ptr.index < 17; ptr++) {
        read_value = *ptr;
        int digit = input[i] - '0';
        if (digit != read_value) {
            return false;
        }
        i++;
    }
    return true;
}
            </code></pre>


            After the password is successfully matched, the user will be granted access to the home system, and the
            system will print "Login success!" to indicate that the user is authorized.

            <pre><code class="'language-c">
Serial.println("Login success!");
            </code></pre>

            At this point, the setup() function will complete its execution, and the program will move to the loop()
            function. The loop() function is where the main operation of the home system begins. This function will be
            used to manage the various home automation and monitoring tasks.

            <pre><code class="'language-c">
void loop() {
    // Functionality for home monitoring and automation.
}
            </code></pre>
            </p>
        </section>
        <section>
            <h2 class="section-header-title">Code Walkthrough for DoorBell with the MCP4821 Speaker</h2>
            <p>
                Objective: Implement a functioning doorbell using PWM and capacitive touch sensor in the middle.

                The full source code for this sketch is located at [05_lab-project/DoorBell/DoorBell.ino]()

                Implementing a doorbell is slightly challenging since we cannot use delay functions as it would
                interfere with other code in the loop function. The doorbell consists of two parts: reading input from
                the capacitive touch sensor and playing notes on the speaker using PWM. First, we need to import the
                Dx_PWM library and set up the speaker and capacitive touch pins. We will also use an external file
                (notes.h) [Refer back to the speaker with PWM code from the previous lab for the notes.h file] for the
                notes.

            <pre><code class="'language-c">
#include <Dx_PWM.h>
#include "notes.h"

#define DOOR_BELL PIN_PC2
#define SPEAKER_PIN PIN_PD2
                                                                                        </code></pre>

            Before the setup function, we set up doorbell tones and declare a note duration:

            <pre><code class="'language-c">
#define NOTE_PERIOD 750
#define DOOR_NOTES_COUNT 2
float door_notes[] = {NOTE_A6S, NOTE_F6S};
                                                                                                        </code></pre>

            We will also need to initialize the Dx_PWM class to play notes through PWM:


            <pre><code class="'language-c">
Dx_PWM* speaker;
                                                                                                                        </code></pre>

            In the setup function, we will need to set the pinModes for the pins and reroute the PWM timer:

            <pre><code class="'language-c">
void setup() {
    pinMode(DOOR_BELL, INPUT);
    pinMode(SPEAKER_PIN, OUTPUT);

    PORTMUX.TCAROUTEA = PORTMUX_TCA0_PORTD_gc;
    speaker = new Dx_PWM(SPEAKER_PIN, 1000.0f, 0.0f);
}
                                                                                                                                        </code></pre>

            In the loop function, we will setup the following code:

            <pre><code class="'language-c">
void loop() {
    static int speaker_index = -1;
    static uint16_t speaker_timer = 0;
    uint16_t now = millis();

    if (speaker_index != -1 && now - speaker_timer > NOTE_PERIOD) {
        speaker_timer = now;
        speaker_index++;
        if (speaker_index < DOOR_NOTES_COUNT) {
        speaker->setPWM(SPEAKER_PIN, door_notes[speaker_index], 0.0f);
        } else {
        speaker_index = -1;
        speaker->setPWM(SPEAKER_PIN, 0.0f, 0.0f);
        }
    }

    bell_value = digitalRead(DOOR_BELL);
    if (bell_value == LOW && speaker_index == -1) {
        speaker_index = 0;
        speaker->setPWM(SPEAKER_PIN, door_notes[speaker_index], 0.0f);
        speaker_timer = now;
    }
}
                                                                                                                                                        </code></pre>

            In the beginning part of the loop function, we set up a few static (meaning consistent between function
            runs) variables to store the speaker index, which is used to track which note is being played, and the
            speaker timer, which is used to track when the speaker should move on the next note. The speaker index is
            set to -1 as a default state to indicate that it is not playing.

            <ul>
                <li>In the first if statement, it checks if the speaker is not playing and checks if the time (note
                    period) since the last note has passed already. When these conditions are met, the speaker timer is
                    updated to the current time, effectively resetting the timer.</li>
                <li>Then, the speaker index is incremented and checked if all notes have been played. If all notes have
                    not been played (ie. not at the end of the note array), then we will continue on to the next note.
                </li>
            </ul>

            In the second half, we read the value from the capacitive touch sensor. When the sensor is being pressed,
            the value is LOW so we check in the if statement if the sensor is being pressed and that the speaker is not
            already playing. Then, the speaker index is updated to 0 and the first note is played from the note array.

            The capacitive touch sensor and speaker need to be connected via pin remapping, so we will reroute PIN_PC3
            to the capacitive touch button's TS4 sensor pin and the PIN_PD2 to the AMP_IN pin to the right of the
            speaker.
            </p>
        </section>
        <section>
            <h2 class="section-header-title">Code Walkthrough for MCP9808 Temperature Sensor with RGB LED</h2>
            <p>
                Objective This program demonstrates how to read temperature data from the MCP9808 sensor via I²C
                communication and visualize it using an RGB LED. The LED color transitions smoothly from blue
                (indicating cold) to red (indicating hot) based on the temperature range.

                The full sketch is located at [05_lab-project/TemperatureSensor/TemperatureSensor.ino]()

                To enable I²C communication and PWM control, we need to include the necessary libraries:

            <pre><code class="'language-c">
#include &lt;Wire.h&gt;
#include "Dx_PWM.h"  // Include the Dx_PWM library to handle PWM functionality on multiple pins
                                                                                                                            </code></pre>

            The Wire.h library establishes I²C communication, and the Dx_PWM.h library provides PWM functionality for
            controlling the LED brightness on multiple pins.
            Next, we define the I²C address for the MCP9808 sensor and configure the RGB LED pins for PWM output:

            <pre><code class="'language-c">
#define MCP9808_ADDR 0x1C  // MCP9808 I²C address

Dx_PWM* PWM_Instance[2];  // Array to store PWM instances for Red and Blue LEDs

// RGB LED pins (ensure they are PWM-capable pins)
const int RED_PIN = PIN_PD1;    // Adjust to your PWM-capable pin for Red
const int BLUE_PIN = PIN_PD3;  // Adjust to your PWM-capable pin for Blue

// Temperature range for LED color interpolation
const float TEMP_MIN = 25.0;   // Minimum temperature for blue
const float TEMP_MAX = 30.0;   // Maximum temperature for red
                                                                                                                                            </code></pre>


            We use Dx_PWM to handle PWM on the LED pins. The TEMP_MIN and TEMP_MAX constants define the temperature
            range over which the LED color transitions from blue to red.
            The setup() function initializes I²C communication, serial communication, and the RGB LED pins. It also
            configures the MCP9808 sensor to continuously measure temperature.

            <pre><code class="'language-c">
void setup() {
    Wire.begin();  // Initialize I²C communication
    Serial.swap(3);
    Serial.begin(115200);  // Initialize serial communication for debugging
    
    // Initialize RGB LED pins for PWM control
    pinMode(RED_PIN, OUTPUT);
    pinMode(BLUE_PIN, OUTPUT);
    
    // Set up PWM instances for the LEDs
    PORTMUX.TCAROUTEA = PORTMUX_TCA0_PORTD_gc;
    PWM_Instance[0] = new Dx_PWM(RED_PIN, 0.0f, 100.0f);  // Red LED PWM
    PWM_Instance[1] = new Dx_PWM(BLUE_PIN, 0.0f, 100.0f);  // Blue LED PWM
    
    // Configure MCP9808 for continuous conversion mode
    Wire.beginTransmission(MCP9808_ADDR);
    Wire.write(0x01);  // Access configuration register
    Wire.write(0x00);  // Set continuous conversion mode
    Wire.write(0x00);
    Wire.endTransmission();
}
                                                                                                                                            </code></pre>

            In this function, Wire.begin() starts I²C communication. The serial port is initialized for debugging. PWM
            pins are configured for the RGB LED. The MCP9808 sensor is set to continuous conversion mode, allowing it to
            update its temperature readings automatically.
            The loop() function continuously reads the temperature from the MCP9808 sensor and updates the RGB LED color
            based on the temperature value.

            <pre><code class="'language-c">
void loop() {
    float temperature = readTemperature();  // Read the current temperature
    Serial.print("Temperature: ");
    Serial.print(temperature);
    Serial.println(" °C");
    
    // Update LED color based on the temperature value
    updateLEDColor(temperature);
}
                                                                                                                                            </code></pre>

            readTemperature() fetches the current temperature from the MCP9808. updateLEDColor() adjusts the RGB LED
            color based on the temperature.
            The readTemperature() function reads the raw temperature data from the MCP9808 sensor, processes it, and
            returns the temperature in Celsius.

            <pre><code class="'language-c">
float readTemperature() {
    Wire.beginTransmission(MCP9808_ADDR);
    Wire.write(0x05);  // Temperature register address
    Wire.endTransmission();
    
    // Request two bytes of temperature data from the sensor
    Wire.requestFrom(MCP9808_ADDR, 2);
    byte msb = Wire.read();
    byte lsb = Wire.read();
    
    // Combine bytes to form raw temperature data
    int temp = ((msb & 0x1F) &lt;&lt; 8) | lsb;
    if (msb & 0x10) {  // Check for negative temperatures
        temp -= 4096;
    }
    
    // Convert to Celsius (MCP9808 conversion factor: 0.0625°C per unit)
    return temp * 0.0625;
}
                                                                                                                                            </code></pre>

            What the readTemperature function does:
            <ul>
                <li>Accesses the temperature register (0x05) of the MCP9808.</li>
                <li>Combines two bytes of data to form the raw temperature value.</li>
                <li>Converts the raw data to Celsius using the MCP9808's conversion factor of 0.0625°C per unit.</li>
            </ul>


            The updateLEDColor() function adjusts the RGB LED color based on the current temperature. The LED color
            interpolates from blue at the minimum temperature to red at the maximum temperature.


            <pre><code class="'language-c">
void updateLEDColor(float temperature) {
    // Clamp temperature to the defined range
    if (temperature < TEMP_MIN) temperature = TEMP_MIN;
    if (temperature > TEMP_MAX) temperature = TEMP_MAX;
    
    // Calculate interpolation factor (0.0 to 1.0)
    float factor = (temperature - TEMP_MIN) / (TEMP_MAX - TEMP_MIN);
    
    // Compute RGB values based on the interpolation factor
    float redValue = factor * 99.9;   // Red increases with temperature
    float blueValue = (1.0 - factor) * 99.9;  // Blue decreases with temperature
    
    Serial.print("Red: ");
    Serial.println(redValue);
    Serial.print("Blue: ");
    Serial.println(blueValue);
    
    // Update the RGB LED using PWM
    PWM_Instance[0]->setPWM(RED_PIN, 100.0f, redValue); //Red LED brightness
    PWM_Instance[1]->setPWM(BLUE_PIN, 100.0f, blueValue);//Blue LED brightness
    delay(50);  // Small delay for smooth transitions
}
                                                                                                                                                            </code></pre>

            What the updateLEDColor function does:
            <ul>
                <li>Clamps the temperature within the defined range (TEMP_MIN to TEMP_MAX).</li>
                <li>Calculates an interpolation factor to linearly map the temperature to a color.</li>
                <li>Adjusts the PWM duty cycle for the red and blue LEDs accordingly, transitioning from blue (cold) to
                    red (hot).</li>
            </ul>
            </p>
        </section>
        <section>
            <h2 class="section-header-title">Code Walkthrough for Smart Lighting</h2>
            <p>

                Objective: Wire the bottom-left switches to the Curiosity Nano and use them to change the color of the
                digitally addressable RGB LEDs.

                Before we begin with the code, we will have to take special steps in order to wire the SW2 and SW3 to
                the Curiosity Nano. This is because the Curiosity Nano is too short to reach the pins from the Curiosity
                Nano Explorer board that correspond to these, so, we will remap them like in the image below to get
                these functioning (it does not have to be these specific pins we remap to, but the rest of the guide
                will be based on them, if you choose somewhere else, make sure it doesn't break any other
                functionality!)

                <img src="../images/arduino_lab4/SmartLighting_Rewire.jpg"
                    style="max-height: 800px; width: 400px;">

            <p>
                With that remapping done, we can begin with our basic imports. (Again, remember to refer to
                pins_arduino.h for your board for the pin numbers!)
            </p>

            The full source code for this sketch is located at [05_lab-project/RoomSelection/RoomSelection.ino]()

            <pre><code class="'language-c">
#define SWITCH_ONE 22 
#define SWITCH_TWO 8
#define SWITCH_THREE 9
#include &lt;tinyNeoPixel.h&gt;
            </code></pre>

            Next, we will declare 2 variables we will use for this program, one being a reference to the pixel_ring,
            with the other being a static list with the necessary colors we want to switch between

            <pre><code class="'language-c">
tinyNeoPixel pixel_ring = tinyNeoPixel(8, PIN_PC3, NEO_GRB + NEO_KHZ800);
unsigned long color_grid[3] = { 0x00007f, 0x007f00, 0x7f0000 };  // Red, green, and blue
                                                                                                                                                                </code></pre>

            In our setup function, we will begin our pixel_ring connection, as well as enabling the specified pins as
            input.

            <pre><code class="'language-c">
void setup() {
    pixel_ring.begin();
    pinMode(SWITCH_ONE, INPUT);
    pinMode(SWITCH_TWO, INPUT);
    pinMode(SWITCH_THREE, INPUT);
}
            </code></pre>

            Now, in this demonstration I will do it by changing all of the LEDs to the specified color, but ideally, it
            would be on a per-room basis as with the room selector. In either case, we will get input from the buttons


            <pre><code class="'language-c">
void loop() {
    // put your main code here, to run repeatedly:
    int i = 0;
    static uint8_t color_index[8] = { 0 }; // Instantiate 8 slots all with default value of 0
    
    int switch_one_value = digitalRead(SWITCH_ONE);
    int switch_two_value = digitalRead(SWITCH_TWO);
    int switch_three_value = digitalRead(SWITCH_THREE);
    
    pixel_ring.clear();
    for(i = 0; i &lt; 8; i++) {
        // This is just one way to do the condition, basic idea is bias left most on over right, remember, board is active LOW
        color_index[i] = switch_one_value == LOW ? 0 : switch_two_value == LOW   ? 1
                                                    : switch_three_value == LOW ? 2                                                                                                                                       
                                                    : color_index[pixel_index];
                                                    pixel_ring.setPixelColor(i, color_grid[color_index[i]]);
    }
    pixel_ring.show();
}
            </code></pre>

            Here, we make a static array of size 8 to hold our value at every LED index, and assess which color to
            assign based on which button is being pressed by reading in whether it is actively being pressed using
            digitalRead. This code can be slightly altered when doing the room selector to only change the color of the
            selected room rather than having a loop to change all of the LEDs to the selected color. That's it for the
            Smart Lighting!
            </p>
        </section>
        <section>
            <h2 class="section-header-title">Code Walkthrough for Room Selector and Joystick</h2>
            <p>
                Objective: Use the potentiometer's read value to determine the selected index (1-8) on the digitally
                addressable LEDs.

                The full source code for this sketch is located at [05_lab-project/RoomSelection/RoomSelection.ino]()

                This walkthrough will be very closely tied to the SmartLighting one, and will give you the basics to
                modify the SmartLighting to include room selection. So if some of the steps or imports seem familiar,
                that's why! We will start by importing our necessary libraries, with 2 real notable ones being the
                definition for the Potentiometer pin, which in this case was 19 per the pins_arduino.h for the Curiosity
                Nano/32DD series boards; And the other being the Adafruit_MCP23008.h, which we will be using to get the
                Joystick input. If you remember the amber LEDs from previous labs, this component is the similar looking
                one on the right of the Amber LED MCP23008.

            <pre><code class="'language-c">
#define POTMETERPIN 19
#include "Adafruit_MCP23008.h"
#include &lt;tinyNeoPixel.h&gt;

Adafruit_MCP23008 joystick;
tinyNeoPixel pixel_ring = tinyNeoPixel(8, PIN_PC3, NEO_GRB + NEO_KHZ800);
unsigned long color_grid[3] = { 0x00007f, 0x007f00, 0x7f0000 };
            </code></pre>

            In our setup function, we do a few things, firstly, we use Serial.swap and Serial.begin to allow us to print
            to the UART, this is primarily just for showing the input from the joystick. Next we again begin the
            pixel_ring connection, and finally we begin the joystick at the given I2C address (found printed above the
            component on the board) and enable all of the Joystick pins as input so we can get data in from them. NOTE:
            the joystick.pullUp call is optional but helps to reset the position after letting go of whatever direction
            you are pointing the joystick. Without this, after pushing up it is likely to not register you letting go.


            <pre><code class="'language-c">
void setup() {
    Serial.swap(3);
    Serial.begin(115200);
    pixel_ring.begin();
    
    uint8_t pin_id;
    joystick.begin(0x24);
    for (pin_id = 0; pin_id < 5; pin_id++) {
        joystick.pinMode(pin_id, INPUT);
        joystick.pullUp(pin_id, HIGH);
    }
}
            </code></pre>

            Finally our large loop function, in this case, we will only be using the 'Red' value, but if you have the
            SmartLighting code functioning you can mix it with this to get it to function such that you can swap the
            color at any specific LED instance. From the top, we start by defining an unsigned integer to hold what LED
            we want to be lit up, defining the default as 0. We then read in the value of the Potentiometer (a value
            between 0-1024, as per analogRead's function), and split it into 8 separate sections. To accomplish this, I
            repeatedly subtract 128 until I can't anymore (again since 128 is 1/8 of 1024), giving us 8 sections or
            ranges that our potentiometer value can fall in. That gives us which index to light up, which all we have to
            do then is clear whatever is currently shown on the pixel ring (to ensure the previous one is turned off
            when changing) and set the led at the correct pixel_index to red, and show it. Moving to the joystick code,
            its fairly simple, just read in using digitalRead at the correct index (labeled on the component, with
            appropriate meaning such as Jleft being 1) and if it comes back as true then we display that text.

            <pre><code class="'language-c">
void loop() {
    uint8_t pixel_index = 0;
    
    int readValue = analogRead(POTMETERPIN);
    
    while (readValue > 128) {
        readValue = readValue - 128;
        pixel_index++;
    }
    
    pixel_ring.clear();
    pixel_ring.setPixelColor(pixel_index, color_grid[0]); // Always Red
    pixel_ring.show();
    
    bool jUp = !joystick.digitalRead(0); 
    bool jLeft = !joystick.digitalRead(1);
    bool jDown = !joystick.digitalRead(2);
    bool jRight = !joystick.digitalRead(3);
    bool jIn = !joystick.digitalRead(4);
    
    if(jUp){
        Serial.println("Pushing up!");
    }
    if(jLeft){
        Serial.println("Pushing Left!");
    }
    if(jDown){
        Serial.println("Pushing Down!");
    }
    if(jRight){
        Serial.println("Pushing Right!");
    }
    if(jIn){
        Serial.println("Pushing In!");
    }
}
            </code></pre>

            That's it for the room selector and joystick! The joystick code can basically stay on its own, but this room
            selector can be easily merged with the SmartLighting to change the color of any specific LED between Red,
            Green, and Blue and also store what it was set to for when you maneuver back to that LED! Give it a try!
            </p>
        </section>
        <section>
            <h2 class="section-header-title">Requirements</h2>
            <p>
                Objective: This program demonstrates how to use the VCNL4200 proximity sensor to detect the proximity of
                an object and trigger an array of amber LEDs controlled by the MCP23008 GPIO expander. The number of
                LEDs illuminated corresponds to the proximity data read from the sensor.

                The full source code for this sketch is located at [05_lab-project/ProximityLED/ProximityLED.ino]()

            <pre><code class="'language-c">
#include "Adafruit_VCNL4200.h"  // Library for VCNL4200 sensor
#include &lt;SPI.h&gt;  // SPI library for communication (used with MCP23008)
#include &lt;Wire.h&gt;  // I2C communication library
#include "Adafruit_MCP23008.h"  // Library for MCP23008 GPIO expander
            </code></pre>

            The required libraries for I2C and SPI communication are included. The Adafruit_VCNL4200 library allows
            communication with the proximity sensor, while the Adafruit_MCP23008 library handles the MCP23008 GPIO
            expander.

            <pre><code class="'language-c">
Adafruit_MCP23008 mcp_leds;  // Instance of MCP23008 for controlling LEDs
Adafruit_VCNL4200 vcnl4200;  // Instance of VCNL4200 proximity sensor
            </code></pre>

            Instances of the MCP23008 and VCNL4200 objects are created to interact with the respective hardware
            components.

            <pre><code class="'language-c">
void setup() {
    Serial.swap(3);  // Platform-specific swap for TX/RX pins
    Serial.begin(115200);  // Initialize serial communication
    
    if (!vcnl4200.begin()) {
        Serial.println("Could not find a valid VCNL4200 sensor, check wiring!");
        while (1) { delay(10); }  // Wait here if sensor is not found
    }
    
    vcnl4200.setALSshutdown(true);  // Disable ambient light sensor
    vcnl4200.setProxShutdown(false);  // Enable proximity sensor
    vcnl4200.setProxHD(false);  // Disable high-definition mode
    vcnl4200.setProxLEDCurrent(VCNL4200_LED_I_200MA);  // Set proximity LED current
    vcnl4200.setProxIntegrationTime(VCNL4200_PS_IT_8T);  // Set proximity integration time
    
    uint8_t pin_id, status;
    status = mcp_leds.begin(0x25);  // Initialize MCP23008 with I2C address 0x25
    
    // Set all 8 MCP23008 GPIO pins as output and turn off LEDs
    for (pin_id = 0; pin_id &lt; 8; pin_id++) {
        mcp_leds.pinMode(pin_id, OUTPUT);  // Set pin mode to output
        mcp_leds.digitalWrite(pin_id, HIGH);  // Turn off LED (HIGH is off for MCP23008)
    }
}
            </code></pre>

            In the setup() function, the serial communication is initialized, and the VCNL4200 proximity sensor is
            configured for use. If the sensor is not found, the program enters an infinite loop and waits for
            corrections. The MCP23008 GPIO expander is also initialized, and all its pins are set as outputs with the
            LEDs initially turned off.

            <pre><code class="'language-c">
void loop() {
    uint16_t proxData = vcnl4200.readProxData();  // Read proximity data from VCNL4200
    Serial.print("Prox Data: ");  // Output proximity data to the serial monitor
    Serial.println(proxData);
    
    LEDs(proxData);  // Call LEDs function to update LED states based on proximity data
    delay(100);  // Wait 100ms before reading data again
}
                            </code></pre>

            In the loop() function, the proximity data is read from the VCNL4200 sensor and printed to the serial
            monitor. The LEDs() function is then called, passing the proximity data to determine how many LEDs to light
            up based on the detected proximity.

            <pre><code class="'language-c">
void LEDs(uint16_t proxData) {
    static unsigned long prox_timer = 0UL;  // Timer to control LED effect timing
    unsigned long now = millis();  // Get the current time in milliseconds
    
    if (now - prox_timer > 200UL) {  // Update LEDs every 200ms
        prox_timer = now;  // Update the timer value
        
        uint8_t numLEDs = map(proxData, 0, 4095, 0, 8);  // Map proximity data to LED count (0 to 8 LEDs)
        
        // Loop through each of the 8 LEDs and turn them on/off based on proximity data
        for (uint8_t i = 0; i &lt; 8; i++) {
            if (i &lt; numLEDs) {
                mcp_leds.digitalWrite(i, LOW);  // Turn on LED (LOW turns on MCP23008 pin)
            } else {
                mcp_leds.digitalWrite(i, HIGH);  // Turn off LED (HIGH turns off MCP23008 pin)
            }
        }
    }
}
                                            </code></pre>


            The LEDs() function controls the lighting of the amber LEDs based on proximity data. It uses the map()
            function to convert the proximity data into a number between 0 and 8, which corresponds to the number of
            LEDs to light up. The LEDs are updated every 200ms using a timer to create a smooth transition in the LED
            pattern. The MCP23008 expander controls the LEDs, with LOW turning the LEDs on and HIGH turning them off.
            </p>
        </section>
        <section>
            <h2 class="section-header-title">Requirements</h2>
            <p>
                To combine the interactive subsystems into one Smart Home system, follow these steps:
            <ol>
                <li>Organize Files:</li>
                <ul>
                    <li>Move all the previous .ino sketches into a folder named SmartHome.</li>
                    <li>Create a new file in this folder named SmartHome.ino.</li>
                </ul>
                <li>Refactor Subsystem Sketches:</li>
                <ul>
                    <li>For each subsystem, rename the setup() function to initializeSystem(), where System is the name
                        of the subsystem</li>
                    <li>Rename the loop() function in each sketch to systemLoop(). For example, If the sketch was for
                        the room temperature selection control system:</li>
                    <pre><code class="'language-c">
                            // Before
                            void setup() {
                                // Room selection setup code
                            }
                            void loop() {
                                // Room selection loop code
                            }
                            // After
                            void initializeRoom() {
                                // Room selection setup code
                            }
                            void roomLoop() {
                                // Room selection loop code
                            }
                    </code></pre>
                </ul>
                <li>Modify SmartHome.ino:</li>
                <ul>
                    <li>In SmartHome.ino, you do not need to include all the subsystem files using #include directives.
                    </li>
                    <li>In the setup() function, call the initializeSystem() function for each subsystem.</li>
                    <li>In the loop() function, call the systemLoop() function for each subsystem.
                    </li>
                    <pre><code class="'language-c">
void setup() {
    initializePassword();
    initializeRoom();
    initializeTemperature();
    initializeDoorBell();
    initializeProximity();
}
void loop() {
    roomLoop();
    temperatureLoop();
    doorBellLoop();
    proximityLoop();
}
                </code></pre>
                </ul>
                <li>Debugging:</li>
                <ul>
                    <li>Verify that there are no duplicate global variable or function names across subsystems. If there
                        are conflicts, rename the variables or functions to make them unique.</li>
                    <li>Test each subsystem individually and then as part of the integrated system to ensure
                        compatibility.</li>
                    <li> HINT: You may run into conflicts while trying to output PWM signals to two different
                        components, the temperature sensor and the doorbell. There are ways to get through it. Good
                        luck!</li>
                </ul>
            </ol>

            The directory containing the combined subsystems is located at [05_lab-project/SmartHome]()
            </p>
        </section>
    </main>
    <footer class="footer">
        <a href="arduino_lab_4_project_requirements.html">
            Back
        </a>
        <a href="../index.html">
            Home
        </a>
    </footer>
</body>

</html>