<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Lab 2: ADC Sampling on the Curiosity Nano</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="../globals.css">
    </head>
    <body>
        <header class="page-header">
            <h1>Introduction to Microcontrollers</h1>
        </header>
        <main>
            <h1 class="lab-header">Lab 2: ADC Sampling on the Curiosity Nano</h1>
            <section>
                <h2 class="section-header-title">Required Materials</h2>
                <ul class="bullet-list">
                    <li>MPLAB X IDE and Compiler</li>
                    <li>Curiosity Nano AVR64DD32 board</li>
                    <li>USB to connect board to computer</li>
                    <li>One jumper cable to connect AIN6 to the on-board 1.5V voltage source</li>
                </ul>
            </section>
            <section>
                <h2 class="section-header-title">Learning Objectives</h2>
                <ul class="bullet-list">
                    <li>Using MCC Melody</li>
                    <li>Viewing pin configurations</li>
                    <li>Configuring and using the ADC</li>
                </ul>
            </section>
            <section>
                <h2 class="section-header-title">What is ADC?</h2>
                <p>
                    Analog to digital converters, or ADCs for short, are used to transfer analog signals read
                    from sensors into workable digital signals that we can use in code. Analog signals are
                    continuous in nature, meaning that their values are not held to strict integer or
                    fixed-point values, which is a necessity when dealing with computers. To solve this,
                    ADCs utilize a break-point like system where values within certain ranges are rounded
                    either up or down to fit as the nature of a digital signal. For example, if a sensor
                    is reading 4.521…, and digitally we are only dealing in whole number integers, digitally
                    it can be rounded to 5. While these breakpoints specifically vary part to part, the
                    general concept will remain the same.
                <p>
                    <img src="../../deliverables/09_lab-2-mplabx/lab/images/01_adc_graph.png" style="width:auto;height:200px;border:1px solid gray"/>
                <p>
                    In addition to looking at the basic idea of an ADC, we will also be exploring the
                    practical use cases, examining the sampling rate and the idea of oversampling in order
                    to reduce random noise in our data collection. The short explanation of this concept
                    is that the “noise” generated by the area around the parts will follow a normal
                    distribution, allowing us to take the average value, increasing the accuracy of
                    our reading and proving the use of over sampling.
                <p>
                    The ADC in the Curiosity Nano has a sampling rate up to 130 ksps at 12-bit resolution.
                    It is connected to an analog input multiplexer for selection between multiple single-ended
                    or differential inputs. In single-ended conversions, the ADC measures the voltage between
                    the selected input and 0V (GND). In differential conversions, the ADC measures the voltage
                    between two selected input channels. The selected ADC input channels can either be internal
                    (e.g., a voltage reference) or external analog input pins. In the next project, we will set
                    up ADC to read input from a 1.5 V on-board voltage source using single-sampling, differential
                    mode, and multi-sampling.
            </section>
            <section>
                <h2 class="section-header-title">Setting up MPLAB X Project and Configuring ADC & I2C</h2>
                <ol class="bullet-list">
                    <li><strong>Copy and Rename Project</strong>
                        <ul class="bullet-list">
                            <li>Open the <strong>Project View</strong> and highlight <strong>mplab_lab1</strong></li>
                            <li><strong>Right-click → Project → Copy</strong>. Rename the new project to <strong>mplab_lab2</strong>.</li>
                            <li>Click <strong>copy</strong></li>
                            <p>
                            <img src="../../deliverables/09_lab-2-mplabx/lab/images/02_screenshot.png" style="width:auto;height:500px;border:1px solid gray;"/></ul>
                    </li>
                    <p>
                    <li><strong>Resolve Code Assistance Errors</strong>
                        <ul class="bullet-list">
                            <li>If red errors appear for certain types or functions that should be recognized:
                                <ul>
                                    <li>Right-click on <strong>mplab_lab2</strong>.</li>
                                    <li>Navigate to <strong>Code Assistance > Reparse Project</strong>.</li>
                                    <li>This resets internal indexing to recognize standard headers like <i>stdio.h</i> and <i>util/delay.h.</i></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <p>
                    <li><strong>Add ADC Driver to MCC</strong>
                        <ul class="bullet-list">
                            <li>Open <strong>MCC</strong></li>
                            <li>Go to <strong>Resource Management -> Drivers</strong></li>
                            <li>Click the green + next to <strong>ADC</strong></li>
                            <p>
                            <img src="../../deliverables/09_lab-2-mplabx/lab/images/03_screenshot.png" style="height:150px;width:auto;border:1px solid gray">
                        </ul>
                    </li>
                    <p>
                    <li><strong>Configure ADC Settings</strong>
                        <ul class="bullet-list">
                            <li>Keep default settings <strong>Single-Ended Mode</strong> and <strong>12-bit resolution</strong>.</li>
                            <li>The <strong>positive input channel</strong> defaults to <strong>AIN1</strong>, but this will be changed later via a function call.</li>
                            <li><strong>Computation mode</strong> remains unchanged for now (single sample, no multiple sampling).</li>
                            <li><strong>Clock Prescaler</strong>: Set to <strong>divide by 2</strong> → results in a <strong>12 MHz clock.</strong></li>
                            <li>Keep <strong>default settings</strong>, then <strong>Generate Code.</strong></li>
                            <li><strong>VREF</strong> should now appear under <strong>Project Resources</strong> (not in the Application Builder diagram view).</li>
                            <p>
                            <img src="../../deliverables/09_lab-2-mplabx/lab/images/04_screenshot.png" style="height:150px;width:auto;border:1px solid gray"/>
                            <p>
                            <li><strong>Double-click VREF</strong> to open its configuration settings.</li>
                            <p>
                            <img src="../../deliverables/09_lab-2-mplabx/lab/images/03_screenshot.png" style="height:140px;width:auto;border:1px solid gray">
                            <li><strong>In the VREF tab, under Easy View, set VDD as Reference (board supply voltage is 3.3V).</strong>
                                <ul>In the first program, we will sample voltages every 2 seconds.</ul>
                            </li>
                        </ul>
                    </li>
                </ol>

            </section>
            <section>
                <h2 class="section-header-title">Code Walkthrough I: ADC Voltage Sampling with AIN6 and AIN7</h2>
                <ol class="bullet-list">
                    <li><strong>Overview</strong>
                        <p>
                        The first program in this lab is designed to interface with the board’s Analog-to-Digital
                        Converter (ADC) and transmit single-sampled voltage readings over UART. The main objective
                        is to periodically read ADC values from two analog input channels (AIN6 and AIN7) and send
                        the data via UART for monitoring.
                        <p>
                        To achieve this, the program:
                        <ul class="bullet-list">
                            <li>Initializes the system using MCC-generated functions.</li>
                            <li>Implements a software timer to control the ADC sampling rate.</li>
                            <li>Reads ADC channels using MCC-generated functions.</li>
                            <li>Uses UART communication to transmit the sampled data.</li>
                        </ul>
                        <p>
                        We will use the board’s 1.5V sample source and connect it to AIN6. The ADC reading from
                        AIN6 will be compared to the reading from AIN7, which is internally wired to the potentiometer.
                        As stated in the project setup, the ADC resolution is 12-bit and the reference voltage (Vref)
                        is 3.3V, which matches the board’s supply voltage. The ADC converts an input voltage (Vin)
                        into a digital value using the formula:
                        <p>
                        <img src="../../deliverables/09_lab-2-mplabx/lab/images/05_formula.png" style="height:60px;
                        width:auto;"/>
                        <p>
                        We will connect a jumper cable from AIN6 to VREF_P1V50B, as shown below. This ensures that
                        AIN6 receives a 1.5V reference voltage. Additionally, remove the jumper cap located next to
                        the ADC6 input, as indicated in the picture.
                        <p>
                        📌<strong>This lab can be found in Lab2/Code/mplab_lab2.X</strong>
                        <p>
                        <img src="../../deliverables/09_lab-2-mplabx/lab/images/06_board.jpg" style="height:300px;
                        width:auto;"/>
                    </li>
                    <li><strong>Necessary Directives</strong>
                        <p>
                            The following directives are required for the program to function correctly:
                            <pre><code class="'language-c">#include "mcc_generated_files/system/system.h"
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;</code></pre>
                        <ol type="a">
                            <li><strong>system.h</strong> – This import directive was covered in Lab 1. It includes our hardware-specific configuration header file.</li>
                            <li><strong>string.h</strong> – Enables string handling (e.g. strlen, sprintf)</li>
                            <li><strong>stdio.h</strong> - Required for formatted input/output operations, such as sprintf for constructing messages.</li>
                        </ol>
                    </li>
                    <p></p>
                    <li><strong>Global Variables and Function Prototypes</strong>
                        <p></p>
                            To keep the code walkthrough organized, we categorize the global variables and
                            function prototypes into three main sections:
                        <ol type="a">
                            <p></p>
                            <li><strong>UART Communication</strong>
                                <p>
                                    Handles sending data via UART for debugging and monitoring
                            <pre><code class="'language-c">void UART_WriteString(const char *message); // enables UART communication
char uart_str[80];                          // provides a buffer for messages</code></pre>
                                <ol type="i">
                                    <li><strong>UART_WriteString() - </strong>Sends a string message over UART, character by character.</li>
                                    <li><strong>uart_str[80] -</strong> A character buffer used to store messages before sending them over UART.</li>
                                </ol>
                            </li>
                            <p></p>
                            <li><strong>Timer Management</strong>
                            <pre><code class="'language-c">volatile uint32_t timer = 0UL;     // This is unsigned long zero.
void tcb_softtimer(void);          // Timer interrupt callback.
void clear_timer(void);            // Resets timer.
uint32_t read_timer(void);         // Reads the current timer value.</code></pre>
                                <ol type="i">
                                    <li><strong>timer</strong> - Sends a string message over UART, character by character.</li>
                                    <li><strong>tcb_softtimer</strong>  – Timer interrupt callback. Increments timer on every interrupt.</li>
                                    <li><strong>clear_timer</strong> - Resets the timer variable.</li>
                                    <li><strong>read_timer</strong> - Returns the current timer value safely.</li>
                                </ol>
                            </li>
                            <p></p>
                            <li><strong>ADC Sampling</strong>
                            <pre><code class="'language-c">void sample_voltages(void);          // Reads ADC values.
int16_t adc_val;                     // Stores the last ADC reading.</code></pre>
                                <ol type="i">
                                    <li><strong>sample_voltages</strong> - Reads ADC values periodically and sends them over UART.</li>
                                    <li><strong>adc_val </strong>  – Stores the last ADC reading.</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                    <p></p>
                    <li>
                        <strong>Initialization</strong>
                        <p></p>
                        The main function of the program begins by initializing system hardware with the function
                        SYSTEM_Initialize();. It is an MCC-generated function that initializes clock settings,
                        GPIOs, ADC, UART, and the Timer. It is defined in system.h
                        <pre><code class="'language-c">int main(void)
{
    SYSTEM_Initialize();</code></pre>
                        <p></p>
                        The next line registers tcb_softtimer() as a callback function for Timer0 interrupts,
                        and the following one resets the software timer.
                        <pre><code class="'language-c">    Timer0.TimeoutCallbackRegister(tcb_softtimer);
    clear_timer();</code></pre>
                        <p></p>
                        This line transmits a startup message over UART before initiating ADC sampling in sample_voltages().
                        <pre><code class="'language-c">    UART_WriteString("MPLAB X - MCC lab3 - ADC\r\n");
    while (1)
    {
          sample_voltages();
    }
}</code></pre>
                    </li>
                    <li><strong>Program Execution: Voltage Sampling Function</strong>
                        <p></p>
                        The sample_voltages() function is responsible for periodically reading ADC values from two
                        analog input channels (AIN6 and AIN7) and transmitting the results over UART. This function
                        ensures that ADC sampling occurs at defined intervals using a software timer.
                        <pre><code class="language-c">void sample_voltages(void)
{
    static unsigned adc_sample_count = 0;
    uint16_t chan7_cnt, chan6_cnt;</code></pre>
                        <ul type="a">
                            <li><strong>adc_sample_count</strong> - This static variable keeps track of the number of samples taken.</li>
                            <li><strong>chan7_cnt, chan6_cnt</strong> – These variables store the ADC readings from AIN6 and AIN7.</li>
                        </ul>
                        <pre><code class="language-c">    if(read_timer() > 2000lu)
    {</code></pre>
                        <ul>
                            <li><strong>if(read_timer() > 2000lu) :</strong> This line calls read_timer() to check if 2000 timer ticks have elapsed</li>
                        </ul>
                        <pre><code class="language-c">        clear_timer();</code></pre>
                        <ul>
                            <li><strong>clear_timer(): </strong>Every time the timer interval is reached, this line clears
                                the timer to restart the timing interval.</li>
                        </ul>
                        <pre><code class="language-c">        adc_sample_count++;</code></pre>
                        <ul>
                            <li><strong>adc_sample_count++ : </strong>This increments the counter that stores our total number of samples.</li>
                        </ul>
                        <pre><code class="language-c">        chan6_cnt = ADC0_ChannelSelectAndConvert(ADC_MUXPOS_AIN6_gc);
        chan7_cnt = ADC0_ChannelSelectAndConvert(ADC_MUXPOS_AIN7_gc);</code></pre>
                        <ul>
                            <li><strong>ADC0_ChannelSelectAndConvert() :</strong> This is an MCC function that selects
                                an ADC channel, initiates a conversion, and returns the sampled digital value. The
                                conversion performed in this function is from an analog voltage to a digital ADC value.</li>
                        </ul>
                        <pre><code class="language-c">        sprintf(uart_str,"sample: %d chan 6 %d chan 7 %d\r\n",
                adc_sample_count, chan6_cnt, chan7_cnt);</code></pre>
                        <ul>
                            <li><strong>sprintf() :</strong> This function formats an output string for UART transmission.</li>
                        </ul>
                        <pre><code class="language-c">        UART_WriteString(uart_str);
    }
}</code></pre>
                        <ul>
                            <li><strong>UART_WriteString() :</strong> This function sends the formatted ADC values over UART for monitoring.</li>
                        </ul>
                    </li>
                    <p></p>
                    <li><strong>Program Execution: Timer Functions</strong>
                        <p></p>
                        Although our timer function were covered in the previous lab, let's take a moment to review them.
                        <pre><code class="'language-c">void tcb_softtimer(void)
{
    cli();                  // Disable interrupts
    timer++;                // Increment software timer
    sei();                  // Re-enable interrupts
}
void clear_timer(void)
{
    cli();                  // Disable interrupts
    timer = 0;              // Reset timer
    sei();                  // Re-enable interrupts
}

uint32_t read_timer(void)
{
    uint32_t timer_val;

    cli();                  // Disable interrupts
    timer_val = timer;      // Read the timer value
    sei();                  // Re-enable interrupts

    return timer_val;
}</code></pre>
                    </li>
                    <p></p>
                    <li><strong>Program Execution: UART_WriteString()</strong>
                        <p></p>
                        While the UART_WriteString function was covered in a previous lab, let's review it again.
                        <pre><code class="'language-c">void UART_WriteString(const char *message)
{
    static uint16_t spinlock = 0;

    for (int i = 0; i < (int) strlen(message); i++) {
        while (!(UART.IsTxReady()))
            spinlock++;
        UART.Write(message[i]);
    }
}</code></pre>
                    </li>
                    <p></p>
                    <li><strong>Expected Result</strong>
                        <p></p>
                        Just like in Lab 1, save all changes to your project and click the Build for Debugging Main
                        Project button <img style="display: inline-flex" src="../../deliverables/09_lab-2-mplabx/lab/images/build.png">
                        on the toolbar to build the project. Then, click on the Make and Program Device Main
                        Project button <img style="display: inline-flex" src="../../deliverables/09_lab-2-mplabx/lab/images/load.png">
                        to send the program to the board. Navigate to Window ➡ Debugging ➡ Data Visualizer. Use the
                        Data Visualizer to read the UART output. This is what you should see.
                        <p></p>
                        <img src="../../deliverables/09_lab-2-mplabx/lab/images/07_results.png" style="width:300px; height:auto"/>
                        <p></p>
                        Channel 6 reads a range of values from 1846 to 1867, which includes some noise, but gets very close to the expected result.
                        <p></p>
                        <img src="../../deliverables/09_lab-2-mplabx/lab/images/08_formula.png" style="width:auto; height:60px"/>
                        <p></p>
                        If you are observant and move the potentiometer, Channel 7 will display a range of values from 0 to 4095.
                    </li>
                    <p></p>
                    <li><strong>Visualizing Channel 6</strong>
                        <p></p>
                        📌<strong>The ADC Visualizer program can be found in Lab2/Code/ADCVisualizer.exe</strong>
                        <p></p>
                        To use the ADC Visualizer, connect your board with the program already loaded, set the port and
                        baud rate using the options dropdown, then click Start. After collecting 500 samples, we observe
                        that the channel 1 (AIN6) readings range from a minimum of 1857 to a maximum of 1872, with an
                        average value of 1863.
                        <p></p>
                        <img src="../../deliverables/09_lab-2-mplabx/lab/images/adc_single.png" style="width:450px; height:auto"/>
                    </li>
                </ol>
            </section>
            <section>
                <h2 class="section-header-title">Code Walkthrough II: Differential ADC Voltage Sampling with AIN6 and AIN7</h2>
                <ol class="bullet-list">
                    <li><strong>Overview</strong>
                        <p></p>
                        In the second section of this lab, sample_voltages() enhances the previous ADC sampling by introducing
                        differential voltage measurement. This function is almost identical to the previous one up until
                        the point where ADC values are read. However, we introduce a new variable, chan76_cnt, to store the
                        result of the differential measurement between AIN6 and AIN7.
                        <pre><code class="'language-c">void sample_voltages(void)
{
    static unsigned adc_sample_count = 0;
    uint16_t chan7_cnt,chan6_cnt, chan76_cnt;   // This one

    if(read_timer() > 2000lu)
    {

        clear_timer();
        adc_sample_count++;

        chan6_cnt = ADC0_ChannelSelectAndConvert(ADC_MUXPOS_AIN6_gc);
        chan7_cnt = ADC0_ChannelSelectAndConvert(ADC_MUXPOS_AIN7_gc);</code></pre>
                    </li>
                    <li><strong>Differential Mode Configuration and Starting the Conversion</strong>
                        <p></p>
                        The following three lines configure the ADC to read the differential voltage between the two channels.
                        <pre><code class="'language-c">        ADC0.CTRLA |= ADC_CONVMODE_DIFF_gc;  // Set ADC to
                                             // differential mode

        ADC0.MUXPOS = ADC_MUXPOS_AIN7_gc;    // Set positive
                                             // input channel

        ADC0.MUXNEG = ADC_MUXPOS_AIN6_gc;    // Set negative
                                             // to AIN6

        ADC0.COMMAND |= ADC_STCONV_bm;       // Start conversion
</code></pre>
                        <ol type="a">
                            <li><strong>ADC0.CTRLA </strong>- Control Register A allows you to configure differential mode to measure the difference between two input voltages, MUXPOS and MUXNEG.</li>
                            <li><strong>ADC0.MUXPOS </strong>– MUXPOS selects the positive input channel.</li>
                            <li><strong>ADC0.MUXNEG </strong>– MUXNEG selects the negative input channel.</li>
                            <li><strong>ADC0.COMMAND </strong>- This command starts the differential conversion.</li>
                        </ol>
                    </li>
                    <p></p>
                    <li><strong>Waiting for Completion</strong>
                        <p></p>
                        The function waits for the conversion to complete by checking the ADC interrupt flag.
                        <pre><code class="'language-c">        while (!(ADC0.INTFLAGS & 0x01));  // Check ADC interrupt flag
                                          // by isolating the LSB.
</code></pre>
                    </li>
                    <p></p>
                    <li><strong>Reading the Differential Result</strong>
                        <p></p>
                        After the conversion, the result is read directly from the ADC result register.
                        <pre><code class="'language-c">        chan76_cnt = ADC0.RES;           // Read differential result</code></pre>
                    </li>
                    <p></p>
                    <li><strong>Printing Results</strong>
                        <p></p>
                        The function formats and sends the results over UART, including the individual values of AIN6 and AIN7, as well as the differential result.
                        <pre><code class="'language-c">        sprintf(uart_str,"sample: %d chan 6 %d chan 7 %d diff %d\r\n",
                adc_sample_count, chan6_cnt, chan7_cnt, chan76_cnt);

        UART_WriteString(uart_str);</code></pre>
                    </li>
                    <p></p>
                    <li><strong>Restoring ADC Configuration</strong>
                        <p></p>
                        After the measurement, differential mode is disabled to return to standard ADC operation.
                        <pre><code class="'language-c">        ADC0.CTRLA &= ~(ADC_CONVMODE_DIFF_gc);
    }
}</code></pre>
                    </li>
                    <p></p>
                    <li><strong>Expected Results</strong>
                        <p></p>
                        This is what you should see after building, loading the program onto your board, and opening the Data Visualizer.
                        <p></p>
                        <img src="../../deliverables/09_lab-2-mplabx/lab/images/10_results.png" style="width:350px; height:auto"/>
                        <p></p>
                        Chan 6 values (AIN6) consistently range from approximately <strong>1840 to 1875.</strong>
                        Chan 7 values (AIN7) hover around <strong>4080 to 4095</strong>, which is near the maximum ADC
                        value because my potentiometer was maxed. The differential voltage (diff) varies between
                        <strong>1103 and 1129</strong> in the positive range, which is the difference between
                        AIN7 (positive) and AIN6 (negative).
                    </li>
                </ol>
            </section>
            <section>
                <h2 class="section-header-title">Code Walkthrough III: Multi-Sampling ADC for Noise Reduction and Increased Accuracy</h2>
                <ol class="bullet-list">
                    <li><strong>Overview</strong>
                        <p></p>
                        This third version of the program enhances ADC voltage measurement by implementing
                        multi-sampling. Instead of taking a single ADC reading per channel, the system accumulates
                        multiple readings and averages them out to improve accuracy and reduce noise.
                    </li>
                    <p></p>
                    <li><strong>Main Function</strong>
                        <p></p>
                        To begin, please replace the function call to <strong>sample_voltages()</strong> in the main
                        function with a call to a new function <strong>multi_sample_voltages()</strong>. We will
                        define this new function in the following steps.
                        <pre><code class="'language-c">    while (1)
    {
          multi_sample_voltages();
    }</code></pre>
                    </li>
                    <p></p>
                    <li><strong>Setting Sample Count in ADC</strong>
                        <p></p>
                        Before defining the function multi_sample_voltages(), we need to define a helper function
                        to configure the ADC’s hardware accumulation settings. This allows the ADC to automatically
                        take multiple samples and sum them before storing the result. To support this, we define a
                        lookup array samplenum_index[8], which maps valid user-defined sample counts to their
                        corresponding values required by the ADC0.CTRLB register.
                        <pre><code class="'language-c">uint8_t samplenum_index[8] = {
    {1,2,4,8,16,32,64,128}
}

uint8_t ADC0_setsamplenum(uint8_t sample_count)
{
    uint8_t scan_index, ctrlb_val, flag = 0xFF;</code></pre>
                        <ol type="a">
                            <li><strong>scan_index</strong> - Used as a loop index to iterate through the array table and find the corresponding sample count value.</li>
                            <li><strong>ctrlb_val</strong> - Stores the correct value to be written to the ADC0.CTRLB register based on the matched sample count.</li>
                            <li><strong>flag</strong> – Indicates whether the lookup was successful (true) or not (false). Returned by the function to signal success or failure.</li>
                        </ol>
                        <p></p>
                        The following loop searches the lookup table for a matching sample_count. If a match is found,
                        it retrieves the corresponding register value (ctrlb_val) for the ADC CTRLB setting, which is
                        actually the index of the matching element.
                        <pre><code class="'language-c">    for (scan_index = 0; scan_index < 8; scan_index++) {
        if(samplenum_index[scan_index] == sample_count)
           ctrlb_val = scan_index;
    }</code></pre>
                        <p></p>
                        This if branch checks whether the user provided a valid sample_count. If not, it defaults to a
                        single-sample setting (0x00) and sets the flag to indicate failure.
                        <pre><code class="'language-c">    if (ctrb_val == 0xFF) {
        ctrb_val = 0x00;
        flag = false;
    }
    else {
        flag = true;
    }</code></pre>
                        <p></p>
                        The function writes the control value to the CTRLB register, configuring the ADC's accumulation mode internally.
                        <pre><code class="'language-c">    ADC0.CTRLB = ctrlb_val;</code></pre>
                        <p></p>
                        The function returns the status indicating success or failure, based on whether the provided sample count was valid.
                        <pre><code class="'language-c">    return(flag);
}</code></pre>
                    </li>
                    <li><strong>Using Hardware Accumulation to Collect Multiple Samples</strong>
                        <p></p>
                        This function reads ADC values from two input pins (AIN6 and AIN7), using hardware accumulation
                        to collect multiple samples and averages them. It configures ADC, collects samples, processes
                        them, and outputs the results to UART. Before we define the function, we need to define a
                        constant to hold the user-defined number of samples. In this example, we will choose 32 samples.
                        Then, we start defining the function with static variables to store results and keep track of
                        the sample count:
                        <pre><code class="'language-c">#define SAMPLE_NUM 32

void multi_sample_voltages(void){
    static uint16_t adc_sample_count = 0;      // Keep track of the count.
    static uint16_t ch6_raw, ch7_raw = 0;      // Store results.</code></pre>
                        <p></p>
                        Before taking new samples, we ensure that 1.5 s have passed since the last read using the timer.
                        If more than 1,500 timer ticks have passed, we clear the timer and increment adc_sample_count
                        to keep track of the number of sample sets. The number 1500lu is a 16-bit unsigned integer value
                        in milliseconds.
                        <pre><code class="'language-c">    if(read_timer() > 1500lu)
    {
        clear_timer();
        adc_sample_count++;</code></pre>
                        <p></p>
                        The following condition attempts to accumulate a specified number of samples by calling
                        ADC0_setsamplenum(SAMPLE_NUM). If the function returns true, it means the configuration
                        is valid, and we proceed with sampling.
                        <pre><code class="'language-c">        if(ADC0_setsamplenum(SAMPLE_NUM))
        {</code></pre>
                        <p></p>
                        We now configure the ADC to read from channel 6 (AIN6). The ADC conversion is started.
                        After it is complete, the result is read into ch6_raw and averaged by dividing by SAMPLE_NUM.
                        <pre><code class="'language-c">            ADC0_ChannelSelect(ADC_MUXPOS_AIN6_gc);// Select channel 6
            ADC0_ConversionStart();                // Start conversion
            while(!ADC0_IsConversionDone());       // Wait for completion
            ch6_raw = ADC0.RES;                    // Read result
            ch6_raw /= (uint16_t)(SAMPLE_NUM);     // Calculate average</code></pre>
                        <p></p>
                        When accumulating more than 16 samples, the result may exceed the capacity of the 16-bit result
                        register. To prevent overflow, the least significant bits (LSBs) of the result are truncated
                        to ensure it fits within the available register size, as described below:
                        <ul class="bullet-list">
                            <p></p>
                            <li><strong>For 32 samples:</strong> The last bit is truncated, making the accumulated result half as large.</li>
                            <li><strong>For 64 samples:</strong> The last 2 bits are truncated, causing the result to be four times smaller.</li>
                            <li><strong>For 128 samples:</strong> The last 8 bits are truncated, resulting in the result being eight times smaller.</li>
                        </ul>
                        <p></p>
                        For example, since our ADC has a 12-bit resolution, meaning the highest possible reading is 2^12 - 1,
                        if we accumulate 32 samples, the highest possible result would be 32 × ((2^12) - 1), which exceeds
                        the capacity of a 16-bit register (2^16). The result is automatically truncated to fit within the register.
                        In other words,
                        <p></p>
                        11111111111100000 (a 17-bit number) becomes
                        <br>
                        1111111111110000  (a 16-bit number)
                        <p></p>
                        giving a value of 131,040 / 2 = 65,520. To correct for this truncation, we apply a manual
                        multiplication by 2 to restore the original value. The correction is applied for each number
                        of samples as follows:

                        <pre><code class="'language-c">            if(SAMPLE_NUM == 32)                // Correct for truncation
                ch6_raw *= 2;
            if(SAMPLE_NUM == 64)
                ch6_raw *= 4;
            if(SAMPLE_NUM == 128)
                ch6_raw *= 8;</code></pre>
                        <p></p>
                        Similarly, we configure the ADC to read from channel 7 (AIN7), start the conversion, wait for
                        it to complete, average the result by the number of samples, and correct for truncation:
                        <pre><code class="'language-c">            ADC0_ChannelSelect(ADC_MUXPOS_AIN6_gc);// Select channel 7
            ADC0_ConversionStart();                // Start conversion
            while(!ADC0_IsConversionDone());       // Wait for completion
            ch7_raw = ADC0.RES;                    // Read result
            ch7_raw /= (uint16_t)(SAMPLE_NUM);     // Calculate average

            if(SAMPLE_NUM == 32)                // Correct for truncation
                ch7_raw *= 2;
            if(SAMPLE_NUM == 64)
                ch7_raw *= 4;
            if(SAMPLE_NUM == 128)
                ch7_raw *= 8;</code></pre>
                    </li>
                    <li><strong>Printing Results</strong>
                        <p></p>
                        The results of the sampling are printed to UART. This includes the current sample count
                        and the results of channels 6 and 7:
                        <pre><code class="'language-c">            sprintf(uart_str,"sample %04u accumulated samples %d\r\n",
                adc_sample_count, SAMPLE_NUM);
            UART_WriteString(uart_str);
            sprintf(uart_str,"chan 6 %04u chan 7 %04u \r\n",
                ch6_raw, ch7_raw);
            UART_WriteString(uart_str);
        }</code></pre>
                    </li>
                    <li><strong>Error Handling</strong>
                        <p></p>
                        If the ADC0_setsamplenum(SAMPLE_NUM) function returns false, indicating an invalid sample count,
                        we output an error message to the UART:
                        <pre><code class="'language-c"></code>        else
        {
            sprintf(uart_str,"invalid number of samples specified");
            UART_WriteString(uart_str);
        }
    }
}</pre>
                    </li>
                    <li><strong>Expected Results</strong>
                        <p></p>
                        After building, loading the program onto your board, and opening the Data Visualizer, you should
                        see more stability in your results. This is an example of the program’s output with an
                        accumulation of 32 samples. As you increase the number of samples, what should happen?
                        <p></p>
                        <img src="../../deliverables/09_lab-2-mplabx/lab/images/11_results.png" style="width:300px;height:auto"/>
                    </li>
                    <p></p>
                    <li><strong>Visualizing Channel 6</strong>
                        <p></p>
                        Running the new program in ADC Visualizer, we see a drastically smaller range of readings than
                        without using oversampling:
                        <p></p>
                        <img src="../../deliverables/09_lab-2-mplabx/lab/images/adc_multi.png" style="width:450px; height:auto"/>
                        <p></p>
                        Running the new oversampling program in the ADC Visualizer with 500 samples, we observe a
                        significantly smaller range of readings compared to the non-oversampled results. In fact,
                        the program returned a consistent value of 1860 for nearly 450 of the samples. The remaining
                        readings were 1864, making up only about 10% of the total. This demonstrates how oversampling
                        effectively reduces noise and provides more stable and reliable measurements.
                    </li>
                </ol>
            </section>
        </main>
        <footer class="footer">
            <a href="mplabx_lab_1.html">
                Back
            </a>
            <a href="mplabx_lab_3.html">
                Next
            </a>
        </footer>
    </body>
</html>